# -*- coding: UTF-8 -*-
from types import EllipsisType
from typing import MutableMapping, MutableSequence, TypedDict

from ._util import getitem_or_def, int_or_def, iter_or_def, str_or_repr
from .types import (
    ID,
    URLID,
    Timestamp,
    URLID_gen,
    URLStr,
    URLStr_,
    Word,
    WordFrequency,
    WordID,
    WordID_gen,
    WordPosition,
)


class Scheme:
    """
    Database scheme.
    """

    __slots__ = ()

    class Root(TypedDict):
        """
        Database root scheme.
        """

        url_ids: MutableMapping[URLStr_, URLID]
        """
        Mapping from URLs to URL IDs.
        """
        word_ids: MutableMapping[Word, WordID]
        """
        Mapping from words to word IDs.
        """

        pages: MutableMapping[URLID, "Scheme.Page"]
        """
        Page metadata.
        """

        inverted_index: MutableMapping[
            WordID, MutableMapping[URLID, MutableSequence[WordPosition]]
        ]
        """
        Mapping from a word and a URL to the locations of the word in the page for the URL. The sequence of locations are sorted and do not contain duplicates.
        """

        # autogenerated data

        forward_index: MutableMapping[URLID, MutableMapping[WordID, WordFrequency]]
        """
        Mapping from a URL and a word to the number of occurrence of the word in the page for the URL.

        This field is autogenerated from `inverted_index`.
        """

        urls: MutableMapping[URLID, URLStr_]
        """
        Mapping from URL IDs to URLs.
        
        This field is autogenerated from `url_ids`.
        """
        words: MutableMapping[WordID, Word]
        """
        Mapping from word IDs to words.

        This field is autogenerated from `word_ids`.
        """

    class Page(TypedDict):
        """
        Database page scheme.
        """

        title: str
        """
        Page title.
        """
        text: str
        """
        Page content in plaintext. That is, without any markups.
        """
        links: MutableSequence[URLStr_]
        """
        Links in the page.
        """
        mod_time: Timestamp | None
        """
        Last modification time.
        """

    @classmethod
    def fix(cls, obj: object) -> "Scheme.Root":
        """
        Convert an object to the scheme format.
        """

        ret = Scheme.Root(
            {
                "url_ids": {},
                "word_ids": {},
                "pages": {},
                "inverted_index": {},
                "forward_index": {},
                "urls": {},
                "words": {},
            }
        )

        cur_obj = getitem_or_def(obj, "url_ids")
        cur_IDs = set[URLID]()
        for key in iter_or_def(cur_obj):
            if (val := getitem_or_def(cur_obj, key)) is ... or (
                val := int_or_def(val)
            ) is ...:
                continue
            key, val = URLStr(str_or_repr(key)), URLID(ID(val))
            if key in ret["url_ids"]:
                continue
            while val in cur_IDs:
                val = URLID_gen()
            cur_IDs.add(val)
            ret["url_ids"][key] = val
        valid_url_ids = cur_IDs

        cur_obj = getitem_or_def(obj, "word_ids")
        cur_IDs = set[WordID]()
        for key in iter_or_def(cur_obj):
            if (val := getitem_or_def(cur_obj, key)) is ... or (
                val := int_or_def(val)
            ) is ...:
                continue
            key, val = Word(str_or_repr(key)), WordID(ID(val))
            while val in cur_IDs:
                val = WordID_gen()
            cur_IDs.add(val)
            ret["word_ids"][key] = val
        valid_word_ids = cur_IDs

        def fix_page(obj: object) -> Scheme.Page | EllipsisType:
            if (cur_obj := getitem_or_def(obj, "text")) is ...:
                return ...
            text = str_or_repr(cur_obj)

            mod_time = int_or_def(getitem_or_def(obj, "mod_time"))
            mod_time = None if mod_time is ... else Timestamp(mod_time)

            return Scheme.Page(
                {
                    "title": str_or_repr(getitem_or_def(obj, "title", "")),
                    "text": text,
                    "links": list(
                        map(
                            URLStr,
                            map(str_or_repr, iter_or_def(getitem_or_def(obj, "links"))),
                        )
                    ),
                    "mod_time": mod_time,
                }
            )

        def fix_key_as_url_id(key: object) -> URLID | EllipsisType:
            try:
                return URLID(ID(int(str_or_repr(key))))
            except (TypeError, ValueError):
                try:
                    return ret["url_ids"][URLStr(str_or_repr(key))]
                except KeyError:
                    return ...

        def fix_key_as_word_id(key: object) -> WordID | EllipsisType:
            try:
                return WordID(ID(int(str_or_repr(key))))
            except (TypeError, ValueError):
                try:
                    return ret["word_ids"][Word(str_or_repr(key))]
                except KeyError:
                    return ...

        cur_obj = getitem_or_def(obj, "pages")
        for key in iter_or_def(cur_obj):
            if (key := fix_key_as_url_id(key)) is ... or key not in valid_url_ids:
                continue
            if (val := getitem_or_def(cur_obj, key)) is ... or (
                val := fix_page(val)
            ) is ...:
                continue
            ret["pages"][key] = val

        # autogenerated data

        cur_obj = getitem_or_def(obj, "inverted_index")
        for key_word_id in iter_or_def(cur_obj):
            if (
                key_word_id := fix_key_as_word_id(key_word_id)
            ) is ... or key_word_id not in valid_word_ids:
                continue
            if (val_word_id := getitem_or_def(cur_obj, key_word_id)) is ...:
                continue
            ret["inverted_index"][key_word_id] = {}
            inverted_index_word = ret["inverted_index"][key_word_id]
            for key_url_id in iter_or_def(val_word_id):
                if (
                    key_url_id := fix_key_as_url_id(key_url_id)
                ) is ... or key_url_id not in valid_url_ids:
                    continue
                if (val_url_id := getitem_or_def(val_word_id, key_url_id)) is ...:
                    continue
                inverted_index_word[key_url_id] = (
                    inverted_index_word_URL := sorted(
                        set(
                            WordPosition(pos)
                            for pos in map(
                                int_or_def, map(str_or_repr, iter_or_def(val_url_id))
                            )
                            if isinstance(pos, int) and pos >= 0
                        )
                    )
                )
                ret["forward_index"][key_url_id][key_word_id] = WordFrequency(
                    len(inverted_index_word_URL)
                )

        ret["urls"].update({val: key for key, val in ret["url_ids"].items()})
        ret["words"].update({val: key for key, val in ret["word_ids"].items()})

        return ret
